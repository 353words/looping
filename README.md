# Advanced Looping In Go
+++
title = "Advanced Looping in Go"
date = "FIXME"
tags = ["golang"]
categories = ["golang"]
url = "FIXME"
author = "mikit"
+++

### Overview

Looping seems like a basic topic: Write a `for` loop with a termination condition, and you're done.
But there's a lot more to loops in Go.
Knowing more about `for` loops will give you more tools to accomplish your tasks and will also help you prevent some bugs.

### Some Assembly Required

What kind of code is generated by the compiler for a `loop`?
To make the assembly output simples, write an empty `for` loop:

***Listing 1: An Empty `for` Loop***

```go
01 package main
02 
03 func main() {
04     for i := 0; i < 3; i++ {
05     }
06 }
```

Listing 1 shows a simple program with an empty `for` loop.

Create the assembly with the following command: `go build -gcflags=-S asm.go > asm.s 2>&1`.
Now let's look at the relevant portion of the generated assembly.
I've modified the output to make it clearer.

**Listing 2: Assembly Output**

```
06     0x0000 00000 asm.go:3    XORL    AX, AX
07     0x0002 00002 asm.go:4    JMP    7
08     0x0004 00004 asm.go:4    INCQ    AX
09     0x0007 00007 asm.go:4    CMPQ    AX, $3
10     0x000b 00011 asm.go:4    JLT    4
```

Listing 2 shows the assembly output of the `for` loop.
On line 06 the `XORL` commands sets the `AX` register to 0.
One line 07 you jump to `7` which is line 09.
On line 09 you compare `AX` to 3 and on line 10 you jump to 4 (line 8) if the result of the comparison is less than (3).
On line 08 you increment `AX` by one.
Then the program will continue to move to line 09, do the comparison again and so forth. 
This will go on until `JLT` on line 10 won't happen (`AX` contains the value 3), and you'll exit the `for` loop.

If you're not familiar with assembly, this logic seems backwards.
But remember that in assembly you only have jumps for flow control, so this is how looping works at that level.
If you want a nice visual display of assembly, check out [lensm](https://github.com/loov/lensm).

### Using More Than One Variable

What happens if you want to use more than a single variable in a `for` loop?:

**Listing 3: Two Variable `for` Loop

```go
25 // IsPalindrome returns true of `s` is a palindrome.
26 func IsPalindrome(s string) bool {
27     rs := []rune(s) // convert to runes
28     for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
29         if rs[i] != rs[j] {
30             return false
31         }
32     }
33 
34     return true
35 }
```

Listing 3 shows a `for` loop with two variables.
On line 27 you initialize `i` and `j` in the init statement,
then in the condition part you check that `i` is less than `j`,
and finally in the post statement you increment `i` and decrement `j`.

Note that you can't write `i++, j--` in the post statement, it's not a valid syntax.

### Naming Loops

Can you detect the bug in the following code?

**Listing 4: Handling Log**

```go
11 type Log struct {
12     Level   string `json:"level"`
13     Message string `json:"message"`
14 }
15 
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18     for {
19         var log Log
20         err := dec.Decode(&log)
21         switch {
22         case errors.Is(err, io.EOF):
23             break
24         case err != nil:
25             return err
26         default:
27             fmt.Printf("log: %+v\n", log)
28         }
29     }
30 
31     return nil
32 }
```

Listing 4 shows a log handler.
On lines 11-13 you define the log message.
On line 18 you start a "forever" loop, on line 20 you decode the next log message.
On line 21 you start a switch statement, on line 22 you check for the end of input and if so break on line 23.
One line 24 you check for error and finally on line 27 you print the log message.

If you run this code, it'll never terminate.
The reason is that the `break` on line 23 breaks out of the `case` and not out of the `for` loop.
The `go vet` command will show you a hint by declaring that line 31 is `unreachable code`.

To solve this issue, you can name the loop using [a label](https://go.dev/ref/spec#Labeled_statements).

**Listing 5: Naming a Loop**

```go
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18 loop:
19     for {
20         var log Log
21         err := dec.Decode(&log)
22         switch {
23         case errors.Is(err, io.EOF):
24             break loop
25         case err != nil:
26             return err
27         default:
28             fmt.Printf("log: %+v\n", log)
29         }
30     }
31 
32     return nil
33 }
```

Listing 5 shows how to fix the bug.
On line 18 you add a label before the loop and on line 24 you break out of the loop.

### The Bank Job

Say you want to give a $1,000 bonus to your VIP bank members.

**Listing 6: Bonus Time**

```go
05 type Account struct {
06     Name    string
07     Type    string
08     Balance int
09 }
10 
11 func main() {
12     bank := []Account{
13         {"donald", "regular", 123},
14         {"scrooge", "vip", 1_000_001},
15     }
16 
17     for _, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20         }
21     }
22     fmt.Println(bank)
23 }
```

Listing 6 shows adding a bonus to every VIP member.
On lines 05-09 you define the `Account` type.
On lines 17-21 you iterate over the account and add a $1,000 bonus to VIP members.
However, when you print the bank on line 22 you don't see a change.
This is since `a` is a copy of the value inside the `bank` slice.
We say the two variable version of `range` uses value semantics.

To solve this bug, you can change the slice to hold pointers.
But a better solution is to use the single variable version of range which uses pointer semantics.

**Listing 7: Pointer Semantics**

```go
17     for _, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20         }
21     }
22     fmt.Println(bank)
```

Listing 7 shows iteration of a slice with pointer semantics.
The increment on line 19 will update the value in the slice, and it'll show when printing on line 22.

Another solution is to use read/modify/write.

**Listing 8: Read, Modify, Write

```go
17     for i, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20             bank[i] = a
21         }
22     }
```

Listing 8 shows a "read,modify,write" solution.
On line 18 you get your own copy of `a`.
Then on line 19 you change the local copy and on line 20 store the new value in the slice.

This solution is great if you want to do "transaction like" changes.
You do several modifications on the local copy, check for validity and only if everything is OK store the new value.

### Bonus Map Range

Say you change `bank` to be a `map` and then try to give a bonus.

**Listing 9: Updating VIP Accounts**

```go
05 type Account struct {
06     Name    string
07     Type    string
08     Balance int
09 }
10 
11 func main() {
12     bank := map[string]Account{
13         "donald":  {"donald", "regular", 123},
14         "scrooge": {"scrooge", "vip", 1_000_001},
15     }
16 
17     for _, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20         }
21     }
22     fmt.Println(bank)
23 }
```

Listing 9 shows an attempt to update a map.
On lines 12-15 you declare `bank` as a map from `login` to `Account`.
On lines 17-21 you give a bonus to every VIP member.

It has the same issue as listing 6: You update a local copy, and it won't be reflected in the map.

You might be tempted to use the same solution as in listing 14.

**Listing 10: Trying Pointer Semantics**

```go
17     for k := range bank {
18         if bank[k].Type == "vip" {
19             bank[k].Balance += 1_000
20         }
21     }
```

Listing 10 shows an attempt to use pointer semantics in a map.
However, this code does not compile, you will see the following error:
`./bank_map_err.go:19:4: cannot assign to struct field bank[k].Balance in map`.

If you try to use a pointer (as in `(&bank[k]).Balance += 1_000`),
it will fail as well with `invalid operation: cannot take address of bank[k]`.

The solution you can use is the read/modify/write solution from listing 15.

**Listing 11: Using Read/Modify/Write with a Map**

```go
17     for l, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20             bank[l] = a
21         }
22     }
```

Listing 11 shows how to use read/modify/write to update a map in a range loop.

### Range Over Numbers

Go 1.22 allows you to loop over integers.

**Listing 12: Looping Over Integers**

```go
09     for i := range 3 {
10         fmt.Println(i)
11     }
```

Listing 12 shows a range over an integer. 
Line 09 is the equivalent of: `for i := 0; i < 3; i++ {`.

I found it handy in benchmark code:

**Listing 13: Benchmark Loop**

```go
22 func BenchmarkEvent_Validae(b *testing.B) {
23     evt := NewEvent("elliot", "read", "/etc/passwd")
24     for range b.N {
25         err := evt.Validate()
26         if err != nil {
27             b.Fatal(err)
28         }
29     }
30 }
```

Listing 13 shows a benchmark.
On line 24 you run `b.N` times instead of the old `for i := 0; i < b.N; i++`.
Since you don't need the value of `i`, you don't place any variable on the left of `range`.

## Range Over Functions

Go 1.22 added [`range over function` experiment](https://tip.golang.org/wiki/RangefuncExperiment).
Go lacks a standard iterator protocol, and this is an attempt to make one.
The idea is that you will produce the values in a function,
and every time you produce a value you pass it to a `yield` function that will handle the value.
The `yield` function call also lets you know when the iteration is done and there's no need to produce more values by returning `false`.

_NOTE: If you are familiar with Python's generators - it's the same idea._

Say you have a slice of events, and you want to filter out non-valid events.

**Listing 14: Event**

```go
21 type Event struct {
22     User string
23     Kind string
24 }
25 
26 func (e Event) Valid() bool {
27     if e.User == "" || e.Kind == "" {
28         return false
29     }
30 
31     return true
32 }
```

Listing 14 shows the `Event` type and the `Valid` method on the event.

Now you can write a generic `Filter` function:

**Listing 15: Filter**

```go
05 func Filter[T any](values []T, pred func(T) bool) func(func(T) bool) {
06     fn := func(yield func(T) bool) {
07         for _, v := range values {
08             if !pred(v) {
09                 continue
10             }
11 
12             if !yield(v) {
13                 break
14             }
15         }
16     }
17 
18     return fn
19 }
```

Listing 15 shows the `Filter` function.
On line 5 you define a generic function with an `any` constraint.
The function accepts a `values` parameter which is a slice and a `pred` which is a predicate function.
`Filter` returns a function that accepts a `yield` function to handle the value.
On line 06 you define the returned iterator function. 
On line 07 you iterate over the slice and on line 08 you skip invalid values.
On line 12 you send a valid value to the `yield` function and check if you need to continue.
Finally on line 18 you return the iterator functions.

Now let's try it out:

**Listing 16: Testing the Filter**

```go
36     events := []Event{
37         {"elliot", "login"},
38         {"", "access"},
39         {"elliot", "logout"},
40     }
41 
42     for e := range Filter(events, Event.Valid) {
43         fmt.Println(e)
44     }
```

On lines 36-40 you define the `events` slice, the event on line 38 is not valid.
On line 42 you range over `Filter` which is called with `events` and `Event.filter` as the predicate.

To run the program you need to set the `GOEXPERIMENT` environment variable to `rangefunc`

**Listing 17: Running the Program**

```
01 $ GOEXPERIMENT=rangefunc go run filter.go 
02 {elliot login}
03 {elliot logout}
```

Listing 17 shows how to run the program.
On line 01 you set the `GOEXPERIMENT` environment variable and use `go run` to run the program.
On lines 01-02 you can see the output which does not contain the invalid event.

### `goto`

`for` is not the only looping construct in Go, there's also `goto`.
Looking at Go 1.22.0 source code, you can see about 650 uses of `goto`:

**Listing 18: Number of `goto` in the Standard Library**

```
01 $ find ~/sdk/go1.22.0/src -type f -name '*.go' -not -path '*test*' -not -name '*_test.go' | \
02     xargs grep -E 'goto\s+' | wc -l
03 657
```

Listing 18 shows how to look for `goto` in the standard library.
On line 01 you use the `find` utility to find non-test files in the Go 1.22 sources.
On line 02 you use `grep` and `wc` to find `goto`s.

Assuming some false positives, this is still a significant use of `goto`.
Even considering [the dangers using goto](https://xkcd.com/292/),
it signals there are valid cases of using `goto`.

Let's change the event processing loop from listing 5 to use goto:

**Listing 19: Using `goto`**

```go
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18     for {
19         var log Log
20         err := dec.Decode(&log)
21         switch {
22         case errors.Is(err, io.EOF):
23             goto done
24         case err != nil:
25             return err
26         default:
27             fmt.Printf("log: %+v\n", log)
28         }
29     }
30 
31 done:
32     return nil
33 }
```

Listing 19 shows an example of using `goto`.
One line 31 you define a `done` label and line 23 when there's no more data, you `goto` this label.

### Conclusion

There's much more to looping than a `for` loop.
Next time you're about to start a loop, think about all the options you have in Go and pick the right one.

What looping idioms did I miss? Tell me at [miki@ardanlabs.com](mailto:miki@ardanlabs.com).


