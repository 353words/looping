# Looping In Go
+++
title = "Looping in Go"
date = "FIXME"
tags = ["golang"]
categories = ["golang"]
url = "FIXME"
author = "mikit"
+++

### Overview

Looping seems like a basic topic - we're all familiar with it.
More so in Go since you only have two looping constructs: `for` and `goto`, and most people don't use `goto`.
However, like any other subject, when you dive deeper - things can get complicated.

In this blog we'll talk about various ways of looping in Go, focusing on semantics and will see the implications on your code.
You might find some bugs in your code as well.

### The `for` Clause

Let's look at the most common form of `for` loops:


**Listing 1: Simple "for" Loop**

```go
08     n := 3
09     for i := 0; i < n; i++ {
10         fmt.Printf("%d ", i)
11     }
```

Listing 1 shows a simple `for` loop, it'll print `0 1 2`.
On line 09 you write a [`For Clause`](https://go.dev/ref/spec#For_statements) statement.
This form has three parts, the first (`i := 0`) is called the `init statemenet` and is optional, 
the second (`i < 3`) is the condition and the last part (`i++`) is called the `post statement`.

Since [Go 1.22](https://tip.golang.org/doc/go1.22#language) you can simplify this code:

**Listing 2: Range Over int**

```go
15     for i := range n {
16         fmt.Printf("%d ", i)
17     }
```

Listing 2 shows the new "range over int" loop.
The loop will run from 0 to `n-1`, and will print `0 1 2`.

### Some Assembly Required

What kind of code is generated by the compiler for a `loop`?
To make the assembly output simples, write an empty `for` loop:

***Listing 3: And Empty `for` Loop***

```go
01 package main
02 
03 func main() {
04     for i := 0; i < 3; i++ {
05     }
06 }
```

Listing 3 shows a simple program with an empty `for` loop.

Create the assembly with the following command: `go build -gcflags=-S asm.go > asm.s 2>&1`.
Now let's look at the relevant portion of the generated assembly.
I've modified the output to make it clearer.

**Listing 4: Assembly Output**

```
06     0x0000 00000 asm.go:3    XORL    AX, AX
07     0x0002 00002 asm.go:4    JMP    7
08     0x0004 00004 asm.go:4    INCQ    AX
09     0x0007 00007 asm.go:4    CMPQ    AX, $3
10     0x000b 00011 asm.go:4    JLT    4
```

Listing 4 shows the assembly output of the `for` loop.
On line 06 the `XORL` commands sets the `AX` register to 0.
One line 07 you jump to `7` which is line 09.
On line 09 you compare `AX` to 3 and on line 10 we jump to 4 (line 8) if the result of the comparison is less than (3).
On line 08 you increment `AX` by one.
Then the program will continue to move to line 09, do the comparison again and so forth. 
This will go on until `JLT` on line 10 won't happen (`AX` is contains the value 3), and you'll exit the `for` loop.

If you're not familiar with assembly, this logic seems backwards.
But remember that in assembly you only have jumps for flow control, so this is how looping works at that level.

### Using More Than One Variable

What happens if you want to use more than a single variable in a `for` loop?:

**Listing 5: Two Variable `for` Loop

```go
25 // IsPalindrome returns true of `s` is a palindrome.
26 func IsPalindrome(s string) bool {
27     rs := []rune(s)
28     for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
29         if rs[i] != rs[j] {
30             return false
31         }
32     }
33 
34     return true
35 }
```

Listing 5 shows a `for` loop with two variables.
On line 27 you initialize `i` and `j` in the init statement,
then in the condition part you check that `i` is less than `j`,
and finally in the post statement you increment `i` and decrement `j`.

Note that you can't write `i++, j--` in the post statement, it's not a valid syntax.


### Omitting `init` and `post`

You can omit the `init` and `post` parts of the `for` loop.
What's left is the equivalent of a `while` loop in other language.

**Listing 6: Fibonacci**

```go
24     // Sum of even Fibonacci numbers up to 4_000_000
25     a, b, total := 1, 2, 0
26     for a <= 4_000_000 {
27         if a%2 == 0 {
28             total += a
29         }
30         a, b = b, a+b
31     }
32     fmt.Println("total:", total)
```

Listing 6 caculates [the sum of event Fibonacci numbers up to 4,000,000](https://projecteuler.net/problem=2).
On line 25 you initialize `a`, `b` and `total`.
On line 26 you run a `for` loop that will terminate when `a` is bigger than 4,000,000.
One lines 27-29 you update the total and on line 30 you increment `a` and `b`. 
This line will cause the `for` loop to terminate.


### Forever Loop

In some cases, you'll know when to terminate the loop inside the loop itself.
In this case you can for a "forever loop".

**Listing 7: Forever Loop**

```go
38 func handler(p Provider) {
39     for {
40         msg := p.Next()
41         if msg == nil {
42             break
43         }
44         // TODO: Handle message
45     }
46 }
```

Listing 7 shows an example of a "forever" loop.
On line 39 you run a `for` loop without an condition (or an `init` and `post`).
On line you get the next message from the provider and on line 41 check if it's nil.
If `msg` is `nil` it means end of input and on line 42 you terminate the `for` loop.


### Naming Loops

Can you detect the bug in the following code?

**Listing 8: Handling Log**


```go

11 type Log struct {
12     Level   string `json:"level"`
13     Message string `json:"message"`
14 }
15 
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18     for {
19         var log Log
20         err := dec.Decode(&log)
21         switch {
22         case errors.Is(err, io.EOF):
23             break
24         case err != nil:
25             return err
26         default:
27             fmt.Printf("log: %+v\n", log)
28         }
29     }
30 
31     return nil
32 }
```

Listing 8 show a log handler.
One lines 11-13 we define the log message.
One line 18 we start a "forever" loop, on line 20 you decode the next log message.
On line 21 you start a switch statement, on line 22 you check for end of input and if so break on line 23.
One line 24 you check for error and finally on line 27 you print the log message.

If you run this code, it'll never terminate.
The reason is that the `break` on line 23 breaks out of the `case` and not out of the `for` loop.
The `go vet` command will show you a hint by declaring that line 31 is `unreachable code`.

To solve this issue, you can name the loop using [a label](https://go.dev/ref/spec#Labeled_statements).

**Listing 9: Naming a Loop**

```go
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18 loop:
19     for {
20         var log Log
21         err := dec.Decode(&log)
22         switch {
23         case errors.Is(err, io.EOF):
24             break loop
25         case err != nil:
26             return err
27         default:
28             fmt.Printf("log: %+v\n", log)
29         }
30     }
31 
32     return nil
33 }
```

Listing 9 shows how to fix the bug.
On line 18 we add a label before the loop and on line 24 we break out of the loop.


### Range Loops

The other format of `for` loops are with a `range` clause.
You can use `range` over integers (since Go 1.22), slices, strings, maps and channels.
The expression on the right in the `range` clause is called "the range expression".
Let's look at each type.

### Integer Range

**Listing 10: Integer Range**

```go
38     for i := range 3 {
39         fmt.Print(i)
40     }
```

Listing 10 shows range over integer.
On line 38 we loop over 3, and the loop will run from 0 to 2.

You can omit the variable on the left, saying "run `n` times".
This is handy in benchmarks.

**Listing 11: Integer Range Without a Variable**

```go
05 func Benchmarkname(b *testing.B) {
06     var data = `{"login": "joe", "path": "/users", "method": "POST"}`
07     for range b.N {
08         err := Decode(data)
09         if err != nil {
10             b.Fatal(err)
11         }
12     }
13 }
```

Listing 11 shows a benchmark.
On line 07 we run `b.N` times and on lines 08-12 we execute the benchmarked code and check for errors.


### Slices Range

You can range over a slice with either a single variable on the left side or two variables on the left side.

**Listing 12: Range Over A Slice**

```go
05 type Account struct {
06     Name    string
07     Type    string
08     Balance int // Â¢
09 }
...
12     bank := []Account{
13         {"donald", "regular", 123},
14         {"scrooge", "vip", 1_000_001},
15     }
16 
17     for i := range bank {
18         fmt.Println(i)
19     }
20 
21     for i, a := range bank {
22         fmt.Printf("%d: %+v\n", i, a)
23     }
24 
25     for _, a := range bank {
26         fmt.Printf("%+v\n", a)
27     }
```

Listing 12 shows iteration over a slice.
On line 17 we use a single variable slice, and `i` will be the slice indices (0 & 1 in this case).
On line 21 we use two variables on the left side, and we get the both the index and a copy of the value.
One line 25 we use the `_` variable to get only the values.

Say you want to give a $1,000 bonus to every VIP member.

**Listing 13: Bonus Time**

```go
29     for _, a := range bank {
30         if a.Type == "vip" {
31             a.Balance += 1_000
32         }
33     }
34     fmt.Println(bank)
```

Listing 12 shows adding a bonus to every VIP member.
However when you print the bank on line 34 you don't see a change.
This is since a is a copy of the value inside the `bank` slice.
We say the two variable version of `range` uses value semantics.

To solve this bug, you can change the slice to hold pointers.
But a better solution is to use the single variable version of range which uses pointer semantics.

**Listing 14: Pointer Semantics**

```go
36     for i := range bank {
37         if bank[i].Type == "vip" {
38             bank[i].Balance += 1_000
39         }
40     }
41     fmt.Println(bank)
```

Listing 14 shows iteration of a slice with pointer semantics.
The increment on line 38 will update the value in the slice and it'll show when printing on line 41.

