# Advanced Looping In Go
+++
title = "Advanced Looping in Go"
date = "FIXME"
tags = ["golang"]
categories = ["golang"]
url = "FIXME"
author = "mikit"
+++

### Overview

Looping seems like a basic topic: Write a `for` loop with a termination condition, and you're done. But there's a lot more to loops in Go. Knowing more about `for` loops will give you more tools to accomplish your tasks and will also help you prevent some bugs.

### Some Assembly Required

What kind of code is generated by the compiler for a `loop`? To make the assembly output simple, I will write an empty `for` loop:

**Listing 1: An Empty `for` Loop**  
```
01 package main
02 
03 func main() {
04     for i := 0; i < 3; i++ {
05     }
06 }
```

Listing 1 shows a simple program with an empty `for` loop that iterates 3 times.

You can create the assembly with the following command:

`go build -gcflags=-S asm.go > asm.s 2>&1`.

Now look at the portion of the generated assembly that is associated with the loop. I've modified the output to make it clearer.

**Listing 2: Assembly Output**  
```
06     0x0000 00000 asm.go:3    XORL    AX, AX
07     0x0002 00002 asm.go:4    JMP    7
08     0x0004 00004 asm.go:4    INCQ    AX
09     0x0007 00007 asm.go:4    CMPQ    AX, $3
10     0x000b 00011 asm.go:4    JLT    4
```

Listing 2 shows the assembly output of the `for` loop.

On line 06, the `XORL` commands sets the `AX` register to 0. Then on line 07, you jump to `7` which is line 09. On line 09, you compare `AX` to 3 and on line 10, you jump to 4 (line 08) if the result of the comparison is less than (3).

On line 08, you increment `AX` by one. Then the program will continue to move to line 09, do the comparison again and so forth. This will go on until `JLT` on line 10 won't happen (`AX` contains the value 3), and you'll exit the `for` loop.

If you're not familiar with assembly, this logic seems backwards. But remember that in assembly you only have jumps for flow control, so this is how looping works at that level.

If you want a nice visual display of assembly when you have to read it, check out this cool tool.

[lensm](https://github.com/loov/lensm).

### Using More Than One Variable

What happens if you want to use more than a single variable in a `for` loop?

**Listing 3: Two Variable `for` Loop**  
```
25 // IsPalindrome returns true if `s` is a palindrome.
26 func IsPalindrome(s string) bool {
27     rs := []rune(s) // convert to runes
28
29     for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
30         if rs[i] != rs[j] {
31             return false
32         }
33     }
34 
35     return true
36 }
```

Listing 3 shows a `for` loop with two variables. On line 29, you initialize `i` and `j` in the init statement, then in the condition part you check that `i` is less than `j`, and finally in the post statement you increment `i` and decrement `j`.

Note that you can't write `i++, j--` in the post statement, it's not a valid syntax.

### Naming Loops

Can you detect the bug in the following code?

**Listing 4: Handling Log**  
```
11 type Log struct {
12     Level   string `json:"level"`
13     Message string `json:"message"`
14 }
15 
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18
19     for {
20         var log Log
21         err := dec.Decode(&log)
22
23         switch {
24         case errors.Is(err, io.EOF):
25             break
26         case err != nil:
27             return err
28         default:
29             fmt.Printf("log: %+v\n", log)
30         }
31     }
32 
33     return nil
34 }
```

Listing 4 shows you a log handler that reads a stream of logs from `r`. On lines 11-14, you declare the log message. On line 19, you start a "forever" loop and on line 21, you decode the next log message from the `io.Reader`. On line 23, you start a switch statement, on line 24 you check for the end of input (`io.EOF` error) and if so break on line 25. On line 26, you check for errors and if there are no errors,  on line 29, you print the log message.

If you run this code the loop willl never terminate. The reason is that the `break` on line 23 breaks out of the `case` and not out of the `for` loop.

To solve this issue, you can use a label break [a label](https://go.dev/ref/spec#Labeled_statements).

**Listing 5: Naming a Loop**  
```
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18
19 loop:
20     for {
21         var log Log
22         err := dec.Decode(&log)
23
24         switch {
25         case errors.Is(err, io.EOF):
26             break loop
27         case err != nil:
28             return err
29         default:
30             fmt.Printf("log: %+v\n", log)
31         }
32     }
33 
34     return nil
35 }
```

Listing 5 shows how to fix the bug.   On line 19, I added a label before the `for` statement and on line 26, and now I can use the label with the break statement.

### Range Loop Semantics

Say you want to give a $1,000 bonus to your VIP bank members.

**Listing 6: Bonus Time**  
```
05 type Account struct {
06     Name    string
07     Type    string
08     Balance int
09 }
10 
11 func main() {
12     bank := []Account{
13         {"donald", "regular", 123},
14         {"scrooge", "vip", 1_000_001},
15     }
16 
17     for _, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20         }
21     }
22
23     fmt.Println(bank)
24 }
```

Listing 6 shows adding a bonus to every VIP member. On lines 05-09, I define the `Account` type. Then on lines 17-21, I iterate over the account and add a $1,000 bonus to VIP members.

However, when I print the bank on line 23, I don't see the change. This is because the `a` variable is not a reference to the actual `Account` value, but a copy of each `Account` value that the `for range` iterates over. So on line 19, the update is happening to a copy and can’t be seen outside the `for range` statement.  This form of the `for range` is called the value semantic version.

To solve this bug, you can change the slice to hold a reference to each `Account` value using pointers, but don’t do that. Instead a better solution is to use the pointer semantic  version of the `for range`.

**Listing 7: Pointer Semantics**  
```
17     for i := range bank {
18         if bank[i].Type == "vip" {
19             bank[i].Balance += 1_000
20         }
21     }
22
23     fmt.Println(bank)
```

Listing 7 shows iteration of a slice with pointer semantics. The increment on line 19 will now update the actual value in the slice, and it'll show when printing on line 23.

Another solution is to use read/modify/write.

**Listing 8: Read, Modify, Write**  
```
17     for i, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20             bank[i] = a
21         }
22     }
```

Listing 8 shows a "read, modify ,write" solution. On line 17, I get your own copy of the `Account` value stored in `a`. Then on line 19, I change the local copy and on line 20, I store the new value back in the slice.

This solution is great if you want to do "transaction like" changes. You do several modifications on the local copy, check for validity, and only if everything is OK store the new value.

### Bonus Map Range

What happens when you change the slice in the last example to be a `map` and then try to give a bonus.

**Listing 9: Updating VIP Accounts**  
```
05 type Account struct {
06     Name    string
07     Type    string
08     Balance int
09 }
10 
11 func main() {
12     bank := map[string]Account{
13         "donald":  {"donald", "regular", 123},
14         "scrooge": {"scrooge", "vip", 1_000_001},
15     }
16 
17     for _, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20         }
21     }
22
23     fmt.Println(bank)
23 }
```

Listing 9 shows an attempt to update a map. On lines 12-15, I declare the `bank` variable as a map with a key of type string representing a login name and a value of type `Account`. On lines 17-21, I give a bonus to every VIP member.

This code  has the same issue as listing 6: You update a local copy and it won't be reflected back in the map. You might be tempted to use the same solution as in listing 14.

**Listing 10: Trying Pointer Semantics**  
```
17     for k := range bank {
18         if bank[k].Type == "vip" {
19             bank[k].Balance += 1_000
20         }
21     }
```

Listing 10 shows an attempt to iterate over only the keys and reference each value in the map. However, this code does not compile, you will see the following error:

`./bank_map_err.go:19:4: cannot assign to struct field bank[k].Balance in map`.

If you try to use a reference (as in `(&bank[k]).Balance += 1_000`), it will fail as well with `invalid operation: cannot take address of bank[k]`.

The solution you can use is the read/modify/write solution from listing 15.

**Listing 11: Using Read/Modify/Write with a Map**  
```
17     for l, a := range bank {
18         if a.Type == "vip" {
19             a.Balance += 1_000
20             bank[l] = a
21         }
22     }
```

Listing 11 shows you how to use a read/modify/write operation to update a map in a range loop.

### Range Over Numbers

In Go 1.22 you can now loop over an integer.

**Listing 12: Looping Over Integers**  
```
09     for i := range 3 {
10         fmt.Println(i)
11     }
```

Listing 12 shows a range over an integer. Line 09 is the equivalent of:

`for i := 0; i < 3; i++ {`

I found this handy in benchmark code:

**Listing 13: Benchmark Loop**  
```
22 func BenchmarkEvent_Validae(b *testing.B) {
23     evt := NewEvent("elliot", "read", "/etc/passwd")
24
25     for range b.N {
26         err := evt.Validate()
27         if err != nil {
28             b.Fatal(err)
29         }
30     }
31 }
```

Listing 13 shows a benchmark. On line 24, I run `b.N` times using the new syntax instead of the old `for i := 0; i < b.N; i++`.

Since I don't need the value of `i`, I don't place any variable on the left of `range`.

_NOTE: Go 1.22 also added `range over function` experiment, but this is a topic for another blog post._

### `goto`

`for` is not the only looping construct in Go, there's also `goto`.
Looking at Go 1.22.0 source code, you can see about 650 uses of `goto`:

**Listing 18: Number of `goto` in the Standard Library**

```
01 $ find ~/sdk/go1.22.0/src -type f -name '*.go' -not -path '*test*' -not -name '*_test.go' | \
02     xargs grep -E 'goto\s+' | wc -l
03 657
```

Listing 18 shows how to look for `goto` in the standard library.
On line 01 you use the `find` utility to find non-test files in the Go 1.22 sources.
On line 02 you use `grep` and `wc` to find `goto`s.

Assuming some false positives, this is still a significant use of `goto`.
Even considering [the dangers using goto](https://xkcd.com/292/),
it signals there are valid cases of using `goto`.

Let's change the event processing loop from listing 5 to use goto:

**Listing 19: Using `goto`**

```go
16 func logHandler(r io.Reader) error {
17     dec := json.NewDecoder(r)
18     for {
19         var log Log
20         err := dec.Decode(&log)
21         switch {
22         case errors.Is(err, io.EOF):
23             goto done
24         case err != nil:
25             return err
26         default:
27             fmt.Printf("log: %+v\n", log)
28         }
29     }
30 
31 done:
32     return nil
33 }
```

Listing 19 shows an example of using `goto`.
One line 31 you define a `done` label and line 23 when there's no more data, you `goto` this label.

### Conclusion

There's much more to looping than a `for` loop.
Next time you're about to start a loop, think about all the options you have in Go and pick the right one.

What looping idioms did I miss? Tell me at [miki@ardanlabs.com](mailto:miki@ardanlabs.com).
